<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Web Stack Primer: HTML → Node → Next.js</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2rem auto;
        max-width: 800px;
        line-height: 1.6;
        color: #1f2933;
      }
      h1, h2, h3 {
        color: #102a43;
      }
      code {
        background: #f5f7fa;
        border: 1px solid #d9e2ec;
        border-radius: 4px;
        padding: 0 0.3rem;
      }
      pre {
        background: #f4f2ff;
        border: 1px solid #cbd2d9;
        padding: 1rem;
        overflow-x: auto;
        border-radius: 6px;
      }
      ul {
        padding-left: 1.5rem;
      }
      .highlight {
        background: #ffe8d9;
        padding: 0.5rem 0.75rem;
        border-left: 4px solid #f7c948;
        margin: 1.5rem 0;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin: 1rem 0;
      }
      th, td {
        border: 1px solid #d9e2ec;
        padding: 0.5rem 0.75rem;
        text-align: left;
      }
      th {
        background: #f5f7fa;
      }
    </style>
  </head>
  <body>
    <h1>From HTML to Next.js: How the Web Stack Fits Together</h1>

    <p>
      Modern web apps are layered like a club sandwich. This guide peels those layers
      so you can see how plain HTML, browsers, Node.js, and the Next.js framework
      cooperate to serve a rich application like AutoCrate.
    </p>

    <h2>1. The Browser &amp; Plain HTML</h2>
    <p>
      Browsers (Chrome, Firefox, Safari, etc.) understand HTML, CSS, and JavaScript.
      At the most basic level, a website is just an <code>index.html</code> file served
      over HTTP. The browser downloads it and renders the markup.
    </p>

    <pre><code>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello Web&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello world!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

    <div class="highlight">
      <strong>Key idea:</strong> The browser only needs files (HTML + CSS + JS). It doesn’t
      care whether they came from a static host or a complex server.
    </div>

    <h2>2. Servers, HTTP &amp; Node.js</h2>
    <p>
      To deliver those files, you need a web server. A server listens on a port
      (often 80 or 443) and responds to HTTP requests. Many technologies can be used
      to build servers: Apache, Nginx, Python’s Flask, Ruby on Rails, etc.
    </p>
    <p>
      <strong>Node.js</strong> is JavaScript running on the server instead of the browser. It provides:
    </p>
    <ul>
      <li>Access to the file system, network, environment variables, etc.</li>
      <li>Libraries to create HTTP servers.</li>
      <li>A package manager (npm) to pull in dependencies.</li>
    </ul>

    <pre><code>// minimal Node HTTP server
const http = require('http');

const server = http.createServer((req, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello from Node.js!');
});

server.listen(3000, () =&gt; {
  console.log('Server listening on http://localhost:3000');
});
</code></pre>

    <h2>3. React: UI Components in JavaScript</h2>
    <p>
      React lets you build UI as reusable components using JavaScript/TypeScript.
      Traditionally, React apps run entirely in the browser (client-side rendering),
      but they can also be rendered on the server for faster first loads.
    </p>

    <h2>4. Next.js: React + Routing + Server Runtime</h2>
    <p>
      <strong>Next.js</strong> sits on top of Node + React. It gives you:
    </p>
    <ul>
      <li>File-based routing for pages (<code>src/app/page.tsx</code> becomes <code>/</code>).</li>
      <li>Server components and API routes running on Node.</li>
      <li>Bundling, optimization, image handling, etc.</li>
    </ul>

    <table>
      <thead>
        <tr>
          <th>Layer</th>
          <th>Role</th>
          <th>Example in this repo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Browser</td>
          <td>Executes the final HTML/CSS/JS bundle, handles user interaction.</td>
          <td>AutoCrate UI rendered in the user’s browser.</td>
        </tr>
        <tr>
          <td>Next.js</td>
          <td>Framework orchestrating React rendering, routing, data fetching.</td>
          <td><code>src/app/page.tsx</code>, <code>src/components/*</code></td>
        </tr>
        <tr>
          <td>Node.js Runtime</td>
          <td>Executes Next.js server logic and API routes.</td>
          <td>Running <code>npm run dev</code> starts the Node process.</td>
        </tr>
        <tr>
          <td>Operating System</td>
          <td>Hosts Node, provides network/filesystem access.</td>
          <td>Windows/macOS/Linux machine or cloud VM.</td>
        </tr>
      </tbody>
    </table>

    <h2>5. Next.js API Routes</h2>
    <p>
      Inside <code>src/app/api/&lt;name&gt;/route.ts</code> you export functions named
      after HTTP verbs. Next turns each file into an endpoint. For example:
    </p>

    <pre><code>// src/app/api/calculate-crate/route.ts
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const body = await request.json();
  // ...call NX generator, compute result...
  return NextResponse.json({ success: true, data: { /* ... */ } });
}
</code></pre>

    <p>
      When the browser calls <code>fetch('/api/calculate-crate')</code>, Next runs that
      <code>POST</code> function on the server (inside the same Node process). You do
      not need a separate backend app—Next already provides one.
    </p>

    <h2>6. Putting It Together in AutoCrate</h2>
    <ol>
      <li>You run <code>npm run dev</code>. Node.js starts the Next.js dev server.</li>
      <li>Visiting <code>http://localhost:3000</code> downloads the rendered HTML/CSS/JS for <code>src/app/page.tsx</code>.</li>
      <li>When the page needs data, it either computes client-side or calls an API route (still handled by Next).</li>
      <li>React components respond to user input, and updates are sent back to the browser DOM.</li>
    </ol>

    <div class="highlight">
      <strong>Production:</strong> When deployed (e.g., to Vercel), your React code gets bundled
      into optimized assets, and each API route becomes a serverless function.
    </div>

    <h2>7. Extending the Stack</h2>
    <p>
      You can gradually add databases, authentication, queues—each typically accessed
      from the API routes or server components. Node libraries handle the heavy lifting,
      and the browser only ever sees sanitized JSON responses or pre-rendered HTML.
    </p>

    <h2>Cheat Sheet</h2>
    <ul>
      <li><strong>HTML/CSS/JS:</strong> Files the browser understands.</li>
      <li><strong>Node.js:</strong> JavaScript runtime on the server.</li>
      <li><strong>React:</strong> Component model for building UIs.</li>
      <li><strong>Next.js:</strong> Framework on Node that renders React and exposes API routes.</li>
      <li><strong>API Route:</strong> Server code in <code>src/app/api/*</code>, automatically hosted by Next.</li>
    </ul>

    <p>
      With this mental model, you can move between layers confidently—tweak React components for UI, adjust API routes for server logic, and rely on Node + Next to bridge the browser and backend concerns.
    </p>
  </body>
</html>
