import React from 'react';
import { test as base, expect } from '@playwright/experimental-ct-react';
import { CrateConfiguration } from '../../src/types/crate';
import { testConfigurations } from '../fixtures/test-data';

/**
 * Component testing utilities for Playwright CT
 */

// Extend the base test with custom fixtures
export const test = base.extend<{
  defaultConfig: CrateConfiguration;
  largeConfig: CrateConfiguration;
  heavyConfig: CrateConfiguration;
}>({
  defaultConfig: async ({}, use) => {
    await use(testConfigurations.basic);
  },
  largeConfig: async ({}, use) => {
    await use(testConfigurations.large);
  },
  heavyConfig: async ({}, use) => {
    await use(testConfigurations.heavy);
  },
});

export { expect };

/**
 * Mock implementations for Three.js components
 */
export const mockThreeJSComponents = {
  Canvas: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="three-canvas" style={{ width: '100%', height: '400px', background: '#f0f0f0' }}>
      {children}
    </div>
  ),
  OrbitControls: () => <div data-testid="orbit-controls">Orbit Controls</div>,
  Grid: () => <div data-testid="grid">Grid</div>,
  Environment: () => <div data-testid="environment">Environment</div>,
  Html: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="html-overlay">{children}</div>
  ),
  useFrame: () => {},
  useThree: () => ({
    camera: { position: { x: 0, y: 0, z: 0 } },
    scene: {},
    gl: { domElement: document.createElement('canvas') }
  })
};

/**
 * Mock implementations for child components
 */
export const mockChildComponents = {
  CrateAssembly: () => <div data-testid="crate-assembly">Crate Assembly</div>,
  PMIAnnotations: () => <div data-testid="pmi-annotations">PMI Annotations</div>,
  MeasurementTools: () => <div data-testid="measurement-tools">Measurement Tools</div>,
  PerformanceMonitor: () => <div data-testid="performance-monitor">Performance Monitor</div>
};

/**
 * Common test patterns for component testing
 */
export const componentTestPatterns = {
  /**
   * Test component rendering
   */
  testRendering: (component: React.ReactElement, testId: string) => {
    return test('renders correctly', async ({ mount }) => {
      const componentInstance = await mount(component);
      await expect(componentInstance.locator(`[data-testid="${testId}"]`)).toBeVisible();
    });
  },

  /**
   * Test component with different props
   */
  testWithProps: (component: React.ReactElement, testId: string, propName: string, propValue: any) => {
    return test(`handles ${propName} prop correctly`, async ({ mount }) => {
      const componentInstance = await mount(component);
      await expect(componentInstance.locator(`[data-testid="${testId}"]`)).toBeVisible();
      // Add specific assertions based on prop value
    });
  },

  /**
   * Test component interactions
   */
  testInteractions: (component: React.ReactElement, testId: string, interaction: () => Promise<void>) => {
    return test('handles interactions correctly', async ({ mount }) => {
      const componentInstance = await mount(component);
      await expect(componentInstance.locator(`[data-testid="${testId}"]`)).toBeVisible();
      await interaction();
    });
  },

  /**
   * Test component accessibility
   */
  testAccessibility: (component: React.ReactElement, testId: string) => {
    return test('meets accessibility requirements', async ({ mount }) => {
      const componentInstance = await mount(component);
      const element = componentInstance.locator(`[data-testid="${testId}"]`);
      await expect(element).toBeVisible();
      
      // Check for proper ARIA attributes
      const ariaLabel = await element.getAttribute('aria-label');
      const role = await element.getAttribute('role');
      
      // Add more accessibility checks as needed
      expect(ariaLabel || role).toBeTruthy();
    });
  }
};

/**
 * Mock API responses for component testing
 */
export const mockAPIResponses = {
  exportStep: {
    success: {
      success: true,
      data: 'ISO-10303-21; HEADER; /* Generated by AutoCrate */',
      filename: 'crate-design.step',
      size: 1024,
      metadata: {
        version: 'AP242',
        generatedAt: new Date().toISOString(),
        standardsCompliance: 'ISO-10303-21'
      }
    },
    failure: {
      success: false,
      error: 'Export failed due to invalid geometry'
    }
  },
  exportPDF: {
    success: {
      success: true,
      data: 'PDF content...',
      filename: 'crate-design.pdf',
      size: 2048
    },
    failure: {
      success: false,
      error: 'PDF generation failed'
    }
  },
  generateNX: {
    success: {
      success: true,
      data: 'NX expression code...',
      filename: 'crate-design.nx',
      size: 512
    },
    failure: {
      success: false,
      error: 'NX generation failed'
    }
  }
};

/**
 * Test environment setup for components
 */
export const setupComponentTest = () => {
  // Mock global objects that might be needed
  global.WebGLRenderingContext = class WebGLRenderingContext {};
  global.WebGL2RenderingContext = class WebGL2RenderingContext {};
  
  global.ResizeObserver = class ResizeObserver {
    constructor(cb: any) {
      this.cb = cb;
    }
    observe() {}
    unobserve() {}
    disconnect() {}
    cb: any;
  };
  
  global.IntersectionObserver = class IntersectionObserver {
    constructor() {}
    observe() {}
    unobserve() {}
    disconnect() {}
  };
};

