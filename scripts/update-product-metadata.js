#!/usr/bin/env node

const fs = require('node:fs')
const path = require('node:path')

const repoRoot = path.resolve(__dirname, '..')
const changelogPath = path.join(repoRoot, 'docs', 'CHANGELOG.md')
const metadataPath = path.join(repoRoot, 'src', 'data', 'product-metadata.ts')

const releaseHeaderPattern = /^##\s+\[([^\]]+)]\s*-\s*(\d{4}-\d{2}-\d{2})\s*$/gm

const escapeForTs = (value) =>
  value.replace(/\\/g, '\\\\').replace(/"/g, '\\"')

const parseHighlights = (section) => {
  const lines = section
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean)
  const highlights = []
  for (const line of lines) {
    if (/^[-*]\s+/.test(line)) {
      highlights.push(line.replace(/^[-*]\s+/, '').trim())
    }
  }
  return highlights
}

const extractSection = (block, heading) => {
  const pattern = new RegExp(`###\\s+${heading}\\s*\\n([\\s\\S]*?)(?=\\n### |\\n## |$)`, 'i')
  const match = block.match(pattern)
  return match ? match[1].trim() : undefined
}

const parseChangelog = (markdown) => {
  releaseHeaderPattern.lastIndex = 0

  const matches = []
  let match
  while ((match = releaseHeaderPattern.exec(markdown)) !== null) {
    matches.push({
      version: match[1].trim(),
      date: match[2],
      index: match.index,
      headerLength: match[0].length
    })
  }

  if (matches.length === 0) {
    throw new Error('No releases found in changelog. Ensure entries use "## [x.y.z] - YYYY-MM-DD" headings.')
  }

  const releases = []
  for (let i = 0; i < matches.length; i += 1) {
    const current = matches[i]
    const next = matches[i + 1]
    const block = markdown.slice(current.index, next ? next.index : undefined).trim()

    const headerLine = block.split('\n')[0].replace(/^##\s+/, '').trim()
    const headerMatch = headerLine.match(/^\[([^\]]+)]\s*-\s*(\d{4}-\d{2}-\d{2})$/)
    if (!headerMatch) {
      throw new Error(`Invalid release header format for block starting at index ${current.index}`)
    }

    const version = headerMatch[1].trim()
    const date = headerMatch[2]
    const releaseDate = new Date(`${date}T00:00:00.000Z`)
    if (Number.isNaN(releaseDate.getTime())) {
      throw new Error(`Invalid release date for version ${version}`)
    }

    const codenameSection = extractSection(block, 'Codename')
    const codename = codenameSection
      ? codenameSection
          .split('\n')
          .map((line) => line.trim())
          .find(Boolean)
      : undefined

    const highlightsSection = extractSection(block, 'Highlights')
    const highlights = highlightsSection ? parseHighlights(highlightsSection) : []

    releases.push({
      version,
      codename,
      releasedAt: releaseDate.toISOString(),
      highlights
    })
  }

  return releases
}

const formatRelease = (release) => {
  const lines = [
    '    {',
    `      version: "${escapeForTs(release.version)}",`
  ]

  if (release.codename) {
    lines.push(`      codename: "${escapeForTs(release.codename)}",`)
  }

  lines.push(`      releasedAt: "${release.releasedAt}",`)

  if (release.highlights.length > 0) {
    const highlightLines = release.highlights
      .map((highlight) => `        "${escapeForTs(highlight)}"`)
      .join(',\n')
    lines.push('      highlights: [')
    lines.push(highlightLines)
    lines.push('      ]')
  } else {
    lines.push('      highlights: []')
  }

  lines.push('    }')
  return lines.join('\n')
}

const generateMetadataSource = (releases) => {
  const changelogEntries = releases.map(formatRelease).join(',\n')
  const lines = [
    '// This file is auto-generated by scripts/update-product-metadata.js',
    '// Do not edit it manually; update docs/CHANGELOG.md and re-run the generator.',
    '',
    'export interface ReleaseEntry {',
    '  /** Semantic version of the product release. */',
    '  version: string',
    '  /** Codename or short descriptor for internal reference. */',
    '  codename?: string',
    '  /** ISO timestamp (UTC) for when the release was published. */',
    '  releasedAt: string',
    '  /** High-level summary bullets for release notes. */',
    '  highlights: readonly string[]',
    '}',
    '',
    'export interface ProductMetadata {',
    '  name: string',
    '  changelog: readonly ReleaseEntry[]',
    '}',
    '',
    'const fallbackRelease: ReleaseEntry = {',
    '  version: "development",',
    '  codename: "Unreleased",',
    '  releasedAt: new Date(0).toISOString(),',
    '  highlights: []',
    '}',
    '',
    'export const productMetadata: ProductMetadata = {',
    '  name: "Autocrate",',
    '  changelog: [',
    changelogEntries,
    '  ]',
    '}',
    '',
    '/**',
    ' * Returns the latest release entry, falling back to a development placeholder',
    ' * to avoid runtime failures if the changelog has not been populated yet.',
    ' */',
    'export const latestRelease: ReleaseEntry =',
    '  productMetadata.changelog[0] ?? fallbackRelease',
    '',
    'export const currentReleaseVersion = latestRelease.version',
    '',
    'export const currentProductLabel = latestRelease.version',
    '  ? `${productMetadata.name} ${latestRelease.version}`',
    '  : productMetadata.name',
    '',
    'export const getProductLabelForVersion = (version: string): string =>',
    '  version ? `${productMetadata.name} ${version}` : productMetadata.name'
  ]
  return `${lines.join('\n')}\n`
}

const ensureFilesExist = () => {
  if (!fs.existsSync(changelogPath)) {
    throw new Error(`Changelog not found at ${changelogPath}`)
  }
}

const main = () => {
  ensureFilesExist()
  const markdown = fs.readFileSync(changelogPath, 'utf8')
  const releases = parseChangelog(markdown)
  const source = generateMetadataSource(releases)
  fs.writeFileSync(metadataPath, source, 'utf8')
}

try {
  main()
} catch (error) {
  console.error(error instanceof Error ? error.message : error)
  process.exitCode = 1
}
